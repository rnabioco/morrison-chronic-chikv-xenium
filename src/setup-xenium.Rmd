
```{r "{{.x}} xen setup", include = FALSE}
# Slide to process
slide <- {{.x}}

# Default chunk options
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo    = FALSE,
  dpi     = 250
)

# Clustering resolution
xen_clst_rsln <- 10

sffx <- str_c("_s", slide, ".qs")

create_sobjs <- !file.exists(here(params$xen_dir, str_c("xen", sffx)))
```

```{r "{{.x}} xen functions"}
.plot_full_fov <- function(df_in, fov_in, color, trace = list(), clrs,
                           size = 0.3, trace_size = 1, trace_clr = "black") {
  # Format input data
  plt_theme <- umap_theme +
    theme(
      legend.title = element_blank(),
      legend.text  = element_text(size = 28)
    )
  
  dat <- df_in %>%
    filter(fov == fov_in)
  
  n_dat <- dat %>%
    group_by(!!sym(color)) %>%
    summarize(n = n(), .groups = "drop") %>%
    mutate(
      n_lab = str_c(!!sym(color), "\nn = ", label_comma()(n))
    )
  
  # Plot highlighted cells
  res <- trace %>%
    map(~ {
      n_dat <- n_dat %>%
        arrange(desc(!!sym(color) %in% .x), desc(n))
      
      n_labs <- set_names(n_dat$n_lab, n_dat[[color]])
      
      dat %>%
        mutate(!!sym(color) := fct_relevel(!!sym(color), names(n_labs))) %>%
        arrange(!!sym(color)) %>%
        ggplot(aes(y_cell, x_cell, fill = !!sym(color))) +
        geom_point_trace(
          trace_position    = !!sym(color) %in% .x,
          background_params = list(size = size, color = NA),
          size  = trace_size,
          color = trace_clr
        ) +
        scale_fill_manual(values = clrs, labels = n_labs) +
        guides(fill = guide_legend(override.aes = list(size = 10, color = NA))) +
        coord_fixed() +
        plt_theme
    })
  
  if (length(trace) == 1) res <- res[[1]]
  
  res
}

.process_xenium <- function(obj, dims = 1:40, resolution = c(1, 3, 5, 10)) {
  
  res <- obj %>%
    SCTransform(assay = "Xenium") %>%
    RunPCA(
      assay    = "SCT",
      npcs     = 50,
      features = rownames(.)
    ) %>%
    RunUMAP(
      assay     = "SCT",
      reduction = "pca",
      dims      = dims
    )
  
  res <- res %>%
    FindNeighbors(
      assay     = "SCT",
      reduction = "pca",
      dims      = dims
    ) %>%
    FindClusters(resolution = resolution)
  
  u_coords <- res %>%
    FetchData(c("umap_1", "umap_2"))

  res <- res %>%
    AddMetaData(u_coords)
  
  res
}

.classify_t_b <- function(obj, clmn) {
  res <- obj %>%
    classify_markers(
      Ptprc > 0.7,
      feats      = "Ptprc",
      type_label = "other CD45+",
      clst_col   = clmn,
      type_col   = "cell_type"
    ) %>%
    classify_markers(
      cell_type == "other CD45+" & Cd3d > 0.45,
      feats      = c("cell_type", "Cd3d"),
      type_label = "T cells",
      clst_col   = clmn,
      type_col   = "cell_type"
    ) %>%
    classify_markers(
      cell_type == "other CD45+" & Cd19 > 1.1,
      feats      = c("cell_type", "Cd19"),
      type_label = "B cells",
      clst_col   = clmn,
      type_col   = "cell_type"
    )
  
  res
}

.classify_dcs <- function(obj, clmn) {
  res <- obj %>%
    classify_markers(
      cell_type == "other CD45+" & Itgax > 0.15,
      feats      = c("cell_type", "Itgax"),
      type_label = "other DC",
      clst_col   = clmn,
      type_col   = "cell_type"
    ) %>% 
    classify_markers(
      cell_type == "other DC" & Sirpa > 0.15 & Itgam > 0.15,
      feats      = c("cell_type", "Sirpa", "Itgam"),
      type_label = "cDC2",
      clst_col   = clmn,
      type_col   = "cell_type"
    ) %>%
    classify_markers(
      cell_type == "other DC" & Xcr1 > 0.15,
      feats      = c("cell_type", "Xcr1"),
      type_label = "cDC1",
      clst_col   = clmn,
      type_col   = "cell_type"
    ) %>%
    classify_markers(
      cell_type %in% c("other DC", "other CD45+") & Siglech > 0.5,
      feats      = c("cell_type", "Siglech"),
      type_label = "Siglec-H DC",
      clst_col   = clmn,
      type_col   = "cell_type"
    ) 
  
  res
}
```

```{r "{{.x}} xen create object", eval = create_sobjs}
# Identify samples to load
xen_dirs <- dir(
  here(params$xen_res_dir),
  pattern = params$xen_regex[[slide]],
  full.names = TRUE
)

names(xen_dirs) <- xen_dirs %>%
  str_extract(params$xen_sample_regex[[slide]])

# Custom targets
chikv_targets <- unname(params$xen_chikv_targets)
chikv_clmns   <- names(params$xen_chikv_targets)

custom_targets <- chikv_targets %>%
  c(params$xen_custom_targets) %>%
  unique() %>%
  unlist()

# Create Seurat object
# * store custom targets as separate assay
# * filter for >5 features
xen <- xen_dirs %>%
  imap(~ {
    obj <- .x %>%
      LoadXenium(fov = .y) %>%
      subset(nFeature_Xenium > 5)

    gns <- rownames(obj)
    gns <- gns[!gns %in% custom_targets]

    cstm <- obj %>%
      subset(features = custom_targets)

    obj <- obj %>%
      subset(features = gns)

    obj[["Xenium_custom"]] <- cstm@assays$Xenium
    
    obj
  })
```

```{r "{{.x}} xen process object", include = FALSE, eval = create_sobjs}
# Process data
# Add FOV labels
xen <- xen %>%
  imap(~ {
    .x %>%
      mutate_meta(mutate, fov = .y) %>%
      .process_xenium(
        dims = 1:40,
        resolution = xen_clst_rsln
      )
  })
```

```{r "{{.x}} xen cell type reference", eval = create_sobjs}
# Create reference using scRNA-seq data
# Run SCTransform separately, merge, PrepSCTFindMarkers to correct sequencing
#   depth between samples
# * Reference object can only have a single SCT model, so use one mock sample
ref_file <- here(params$xen_dir, "ref_so.qs")

if (!file.exists(ref_file)) {
  ref_so <- here(params$so_dir, "so.qs") %>%
    qread() %>%
    DietSeurat(
      assays    = "RNA",
      layers    = "counts",
      dimreducs = NULL,
      graphs    = NULL
    )
  
  ref_so <- ref_so %>%
    subset(treatment == "mock")
  
  top_sample <- ref_so$orig.ident %>%
    table() %>%
    sort(decreasing = TRUE) %>%
    head(1) %>%
    names()
  
  ref_so <- ref_so %>%
    subset(orig.ident == top_sample) %>%
    SCTransform()
  
  # Filter object to reduce memory requirement
  ref_so <- ref_so %>%
    DietSeurat(assays = c("SCT", "RNA"))
  
  ref_so %>%
    qsave(ref_file)
  
} else {
  ref_so <- qread(ref_file)
}
```

```{r "{{.x}} xen cell type annotations", eval = create_sobjs}
# Identify transfer anchors
anchors <- xen %>%
  map(~ {
    FindTransferAnchors(
      ref_so,
      query = .x,
      query.assay = "SCT",
      normalization.method = "SCT"
    )
  })

preds <- xen %>%
  imap(~ {
    TransferData(
      anchorset        = anchors[[.y]],
      refdata          = ref_so$cell_type,
      prediction.assay = TRUE,
      weight.reduction = .x[["pca"]],
      dims             = 1:40
    )
  })

anchors %>%
  qsave(here(params$xen_dir, str_c("ref_anchors", sffx)))

preds %>%
  qsave(here(params$xen_dir, str_c("ref_preds", sffx)))

# Predict cell types for Xenium data
xen <- xen %>%
  imap(~ {
    .x[["preds"]] <- preds[[.y]]
    
    xen_types <- .x@assays$preds@data %>%
      as_tibble(rownames = "cell_type") %>%
      pivot_longer(-cell_type, values_to = "pred_conf") %>%
      filter(cell_type != "max") %>%
      group_by(name) %>%
      filter(pred_conf == max(pred_conf)) %>%
      mutate(cell_type = if_else(n() > 1, "unassigned", cell_type)) %>%
      ungroup() %>%
      column_to_rownames("name")
    
    .x %>%
      AddMetaData(xen_types)
  })

# Merge objects
xen <- merge(xen[[1]], xen[-1], add.cell.ids = names(xen))

rm(ref_so)
gc()
```

```{r "{{.x}} xen refine annotations", eval = create_sobjs}
# Each FOV was clustered separately, so add FOV ID to cluster ID
xen_clst_clmn <- str_c("SCT_snn_res.", xen_clst_rsln)

xen <- xen %>%
  mutate_meta(~ {
    .x %>%
      rename(rough_type = cell_type) %>%
      mutate(!!sym(clst_clmn) := str_c(fov, "_", !!sym(clst_clmn)))
  })

# Identify CD45+/- cells
xen <- xen %>%
  mutate_meta(
    mutate,
    cd45_class = "other",
    cell_type  = rough_type
  ) %>%
  classify_markers(
    feats      = "Ptprc",
    filt       = Ptprc > 1,
    clst_col   = xen_clst_clmn,
    type_label = "CD45+",
    type_col   = "cd45_class"
  ) %>%
  classify_markers(
    feats      = "Ptprc",
    filt       = Ptprc <= 1,
    clst_col   = xen_clst_clmn,
    type_label = "CD45-",
    type_col   = "cd45_class"
  )

# Refine cell types based on prediction confidence
# * set adipose tissue as unassigned based on Car3 expression
# * set epithelial cells as unassigned since they appear to express CD45
xen <- xen %>%
  mutate_meta(
    mutate,
    cell_type = if_else(pred_conf > 0.5, rough_type, "unassigned")
  ) %>%
  classify_markers(
    feats      = "Car3",
    filt       = Car3 > 0.75,
    clst_col   = xen_clst_clmn,
    type_label = "unassigned",
    type_col   = "cell_type"
  ) %>%
  mutate_meta(
    mutate,
    cell_type = if_else(
      cell_type %in% c("unassigned", "Epithelial cells"),
      str_c("other ", cd45_class),
      cell_type
    ),
    Ag_type = ifelse(Ag_class == "Ag-high", cell_type, "Ag-low")
  )

# Refine B/T cell annotations based on CD19 and CD3 expression
xen <- xen %>%
  classify_markers(
    feats      = "Cd19",
    filt       = Cd19 > 1.1,
    type_label = "B cells",
    clst_col   = xen_clst_clmn,
    type_col   = "cell_type"
  ) %>%
  classify_markers(
    feats      = "Cd3d",
    filt       = Cd3d > 0.6,
    type_label = "T cells",
    clst_col   = xen_clst_clmn,
    type_col   = "cell_type"
  )
```

```{r "{{.x}} xen create lec/frc objects", include = FALSE, eval = create_sobjs}
# Process data
type_key <- c(lec = "LEC", frc = "Fibroblasts")

cd45neg <- type_key %>%
  imap(~ {
    obj <- xen %>%
      subset(cell_type == .x) %>%
      .process_xenium(
        dims = 1:30,
        resolution = c(1, 2, 3, 5)
      )
    
    obj
  })

# Split list
lec <- cd45neg$lec
frc <- cd45neg$frc

rm(cd45neg)
gc()
```

```{r "{{.x}} xen calculate distance from Ag+ LEC", eval = create_sobjs}
# Calculate distance from closest Ag+ LEC
# * this will only return cell coordinates for FOVs with Ag+ LECs
# * FOV F will not have cell coordinates, this column will be all `NA`s
fovs <- sort(unique(xen$fov))

dists <- fovs %>%
  map_dfr(~ {
    # Pull cell centroid coordinates
    cell_coords <- xen@images[[.x]]@boundaries$centroids
    
    cell_coords <- cell_coords@coords %>%
      as_tibble() %>%
      mutate(.cell_id = cell_coords@cells)
    
    cell_meta <- xen@meta.data %>%
      filter(fov == .x) %>%
      as_tibble(rownames = ".cell_id") %>%
      dplyr::select(.cell_id, cell_type, Ag_class)
    
    stopifnot(identical(cell_coords$.cell_id, cell_meta$.cell_id))
    
    cell_meta <- cell_meta %>%
      left_join(cell_coords, by = ".cell_id")
    
    # Convert to sf object (sp package is deprecated)
    # * first convert to sp::SpatialPolygonsDataFrame
    # * mol <- obj@images$A@molecules$molecules$GeoMx_Barcode01_ERCC00142
    # * ensure geometries are valid
    cells <- xen@images[[.x]]@boundaries$segmentation@polygons
    plys  <- SpatialPolygons(cells)
    
    plys <- SpatialPolygonsDataFrame(
      plys,
      data = data.frame(
        id        = seq_along(cells),
        cell_type = cell_meta$cell_type,
        Ag_class  = cell_meta$Ag_class,
        row.names = map_chr(cells, ~ .x@ID)
      )
    )
    
    plys <- plys %>%
      st_as_sf() %>%
      st_make_valid()
    
    # Pull cell types
    lecs <- cell_meta %>%
      filter(cell_type == "LEC" & Ag_class == "Ag-high")
    
    if (nrow(lecs) == 0) return(NULL)
    
    # Calculate distances between each LEC and all other cells
    dists <- st_distance(plys[lecs$.cell_id, ], plys)
    
    rownames(dists) <- lecs$.cell_id
    colnames(dists) <- rownames(plys)
    
    dists <- dists %>%
      as_tibble(rownames = "lec_id") %>%
      pivot_longer(-lec_id, names_to = "other", values_to = "lec_dist") %>%
      left_join(cell_meta, by = c(other = ".cell_id"))
    
    dists <- dists %>%
      left_join(
        cell_coords,
        by     = c(lec_id = ".cell_id"),
        suffix = c("_cell", "_lec")
      )
    
    stopifnot(nrow(dists) == (n_distinct(lecs$.cell_id) * n_distinct(rownames(plys))))
    
    # Determine closest LEC
    # * there are a very small number of ties (<50 cells)
    res <- dists %>%
      group_by(other) %>%
      mutate(
        closest = lec_dist == min(lec_dist),
        fov = .x
      ) %>%
      ungroup()

    res
  })

dist_meta <- dists %>%
  filter(closest) %>%
  group_by(other) %>%
  slice(1) %>%
  ungroup() %>%
  dplyr::select(other, lec_id, lec_dist, matches("^[xy]_")) %>%
  column_to_rownames("other")

xen <- xen %>%
  AddMetaData(dist_meta)
```

```{r "{{.x}} xen lec types", eval = create_sobjs}
# Annotate LEC types
# * automated threshold leaves a small Marco-high cluster as unassigned
lec_clst_clmn <- "SCT_snn_res.3"

ann <- clustify(
  input       = lec@assays$SCT@data,
  ref_mat     = ref_LEC_xiang,
  metadata    = lec@meta.data,
  cluster_col = lec_clst_clmn,
  vec_out     = TRUE,
  threshold   = 0.55
)

names(ann) <- colnames(lec)

lec <- lec %>%
  AddMetaData(ann, col.name = "lec_type")

# Add annotations to meta.data
lec <- lec %>%
  mutate_meta(
    mutate,
    Ag_type = ifelse(Ag_class == "Ag-high", lec_type, "Ag-low")
  )

xen <- xen %>%
  AddMetaData(lec$lec_type, col.name = "lec_type") %>%
  mutate_meta(
    mutate,
    lec_type = replace_na(lec_type, "other")
  )

# Save objects
lec %>%
  save_objs(str_c("lec_s", slide), params$xen_dir)

frc %>%
  save_objs(str_c("frc_s", slide), params$xen_dir)

rm(lec, frc)
gc()
```

```{r "{{.x}} xen small object", eval = create_sobjs}
# Identify CHIKV+ cells
# * set Ag tag signals for each sample based on params$xen_samples
ag_feats <- str_c("xenium_custom_", chikv_targets)

xen <- xen %>%
  imap(~ {
    ag_info <- params$xen_samples[[.y]]
    
    .x %>%
      AddMetaData(
        FetchData(., ag_feats),
        col.name = ag_clmns
      ) %>%
      mutate_meta(~ {
        .x %>%
          mutate(
            CHIKV_class = ifelse(Ag_counts > 0, "Ag-high", "Ag-low")
          )
      })
  })

# Format Ag labels
dcs <- xen$cell_type %>%
  unique() %>%
  grep("DC", ., value = TRUE) %>%
  sort()

lecs <- xen$lec_type %>%
  table() %>%
  sort() %>%
  rev() %>%
  names()

lecs <- lecs[lecs != "other"]

top_types <- c("LEC", dcs)

xen <- xen %>%
  mutate_meta(
    mutate,
    lec_Ag_type    = ifelse(Ag_class == "Ag-high", as.character(lec_type), "Ag-low"),
    lec_Ag_type    = fct_relevel(lec_Ag_type, lecs),
    lec_dc_type    = ifelse(cell_type %in% top_types, as.character(cell_type), "other"),
    lec_dc_type    = fct_relevel(lec_dc_type, top_types),
    lec_dc_Ag_type = ifelse(Ag_class == "Ag-high", as.character(lec_dc_type), "Ag-low"),
    lec_dc_Ag_type = fct_relevel(lec_dc_Ag_type, top_types)
  )

# Select subset of cells to plot
# * too many points to plot, downsample when plotting sections
set.seed(42)

plt_cells <- sample(colnames(xen), 50000)

plt_cells <- xen@meta.data %>%
  filter(cell_type %in% top_types | Ag_class == "Ag-high") %>%
  rownames() %>%
  c(plt_cells) %>%
  unique()

plt_cells <- xen@meta.data[plt_cells, ] %>%
  mutate(cell_type = fct_relevel(cell_type, top_types)) %>%
  arrange(cell_type) %>%
  rownames()

small <- xen %>%
  subset(cells = plt_cells)

# Save objects
xen %>%
  save_objs(
    prfx   = str_c("xen_s", slide),
    ob_dir = params$xen_dir
  )

small %>%
  save_objs(
    prfx   = str_c("small_s", slide),
    ob_dir = params$xen_dir
  )

rm(xen, small)
gc()
```
